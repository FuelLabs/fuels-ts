import type { Abi } from '../Abi';
import { TargetEnum } from '../interfaces/TargetEnum';
import type { EnumType } from '../types/EnumType';
import type { StructType } from '../types/StructType';

/*
  Templates
*/
export function renderDtsEncoderTemplate(params: { functionName: string; input: string }) {
  const { functionName, input } = params;
  return `encodeFunctionData(functionFragment: '${functionName}', values: [${input}]): Uint8Array`;
}

export function renderDtsDecoderTemplate(params: { functionName: string }) {
  const { functionName } = params;
  return `decodeFunctionData(functionFragment: '${functionName}', data: BytesLike): DecodedValue`;
}

export function renderDtsStructExportsTemplate(params: {
  structName: string;
  typeAnnotations: string;
  inputValues: string;
  outputValues: string;
}) {
  const { structName, typeAnnotations } = params;

  const inputValues = `{ ${params.inputValues} }`;
  let outputValues = `{ ${params.outputValues} }`;

  if (inputValues === outputValues) {
    outputValues = `${structName}Input${typeAnnotations}`;
  }

  return [
    `export type ${structName}Input${typeAnnotations} = ${inputValues};`,
    `export type ${structName}Output${typeAnnotations} = ${outputValues};`,
  ].join('\n');
}

export function renderDtsEnumExportsTemplate(params: {
  enumName: string;
  inputValues: string;
  outputValues: string;
}) {
  const { enumName } = params;

  const inputValues = `Enum<{ ${params.inputValues} }>`;
  let outputValues = `Enum<{ ${params.outputValues} }>`;

  if (inputValues === outputValues) {
    outputValues = `${enumName}Input`;
  }

  return [
    `export type ${enumName}Input = ${inputValues};`,
    `export type ${enumName}Ouput = ${outputValues};`,
  ].join('\n');
}

export function renderDtsCommonImportTemplate(params: { commonTypesInUse: string[] }) {
  const { commonTypesInUse } = params;
  return `import type { ${commonTypesInUse.join(', ')} } from "./common";`;
}

/*
  Render method
*/
export function renderDtsTemplate(params: { abi: Abi }) {
  const { name, types, functions, commonTypesInUse } = params.abi;

  /*
    First we format all attributes
  */
  const fnsTypedefs = functions.map((f) => f.getDeclaration());

  const fnsFragments = functions.map((f) => `${f.attributes.name}: FunctionFragment;`);

  const encoders = functions.map((f) =>
    renderDtsEncoderTemplate({
      functionName: f.attributes.name,
      input: f.attributes.inputs,
    })
  );

  const decoders = functions.map((f) =>
    renderDtsDecoderTemplate({
      functionName: f.attributes.name,
    })
  );

  const structs = types
    .filter((t) => t.name === 'struct')
    .map((t) => {
      const st = t as StructType; // only structs here
      const structName = st.getStructName();
      const inputValues = st.getStructContents({ types, target: TargetEnum.INPUT });
      const outputValues = st.getStructContents({ types, target: TargetEnum.OUTPUT });
      const typeAnnotations = st.getStructDeclaration({ types });
      return renderDtsStructExportsTemplate({
        structName,
        typeAnnotations,
        inputValues,
        outputValues,
      });
    });

  const enums = types
    .filter((t) => t.name === 'enum')
    .map((t) => {
      const et = t as EnumType; // only enums here
      const enumName = et.getEnumName();
      const inputValues = et.getEnumContents({ types, target: TargetEnum.INPUT });
      const outputValues = et.getEnumContents({ types, target: TargetEnum.OUTPUT });
      return renderDtsEnumExportsTemplate({
        enumName,
        inputValues,
        outputValues,
      });
    });

  // Handles custom common types
  let commonImports = renderDtsCommonImportTemplate({ commonTypesInUse });

  commonImports = commonTypesInUse.length ? `\n${commonImports}\n` : '';

  // glue everything
  const output = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import type {
  Interface,
  FunctionFragment,
  DecodedValue,
  Contract,
  BytesLike,
  BigNumberish,
  InvokeFunction,
  BN,
} from 'fuels'

${commonImports}

${enums.join('\n')}

${structs.join('\n')}

interface ${name}Interface extends Interface {
  functions: {
    ${fnsFragments.join('\n    ')}
  }

  ${encoders.join('\n  ')}

  ${decoders.join('\n  ')}
}

export class ${name} extends Contract {
  interface: ${name}Interface
  functions: {
    ${fnsTypedefs.join('\n    ')}
  }
}`;

  return output.replace(/[\n]{3,}/g, '\n\n');
}
