import type { Abi } from 'src/abi/Abi';
import type { EnumType } from 'src/abi/types/EnumType';
import type { StructType } from 'src/abi/types/StructType';

/*
  Templates
*/
export const DTS_TEMPLATE = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import type {
  Interface,
  FunctionFragment,
  DecodedValue,
  Contract,
  BytesLike,
  BigNumberish,
  InvokeFunction,
  BN,
} from 'fuels'

{ENUM_IMPORT}

{ENUMS}

{STRUCTS}

interface {NAME}Interface extends Interface {
  functions: {
    {FNS_FRAGMENTS}
  }

  {ENCODERS}

  {DECODERS}
}

export class {NAME} extends Contract {
  interface: {NAME}Interface
  functions: {
    {FNS_TYPEDEFS}
  }
}`;

export const DTS_TEMPLATE_ENCODER = `encodeFunctionData(functionFragment: '{NAME}', values: [{INPUT}]): Uint8Array`;

export const DTS_TEMPLATE_DECODER = `decodeFunctionData(functionFragment: '{NAME}', data: BytesLike): DecodedValue`;

export const DTS_TEMPLATE_STRUCT = `export type {NAME} = { {VALUES} }`;

export const DTS_TEMPLATE_ENUM = `export type {NAME} = Enum<{ {VALUES} }>`;

export const DTS_TEMPLATE_ENUM_IMPORTER = `import type { {TYPES} } from "./common";`;

export const DTS_TEMPLATE_TUPLES = `export type {NAME} = [{VALUES}]`;

/*
  Render method
*/
export function renderDtsTemplate(params: { abi: Abi }) {
  const { name, types, functions, usesEnum, usesOption } = params.abi;

  /*
    First we format all attributes
  */
  const fnsTypedefs = functions.map((f) => f.getDeclaration());

  const fnsFragments = functions.map((f) => `${f.attributes.name}: FunctionFragment;`);

  const encoders = functions.map((f) =>
    DTS_TEMPLATE_ENCODER.replace('{NAME}', f.attributes.name).replace(
      '{INPUT}',
      f.attributes.inputs
    )
  );

  const decoders = functions.map((f) =>
    DTS_TEMPLATE_DECODER.replace('{NAME}', f.attributes.name).replace(
      '{INPUT}',
      f.attributes.inputs
    )
  );

  const structs = types
    .filter((t) => t.name === 'struct')
    .map((t) => {
      const st = t as StructType; // only structs here
      const structName = st.getStructName();
      return DTS_TEMPLATE_STRUCT.replace('{NAME}', structName).replace(
        '{VALUES}',
        st.getStructContents({ types })
      );
    });

  const enums = types
    .filter((t) => t.name === 'enum')
    .map((t) => {
      const et = t as EnumType; // only enums here
      const structName = et.getStructName();
      return DTS_TEMPLATE_ENUM.replace('{NAME}', structName).replace(
        '{VALUES}',
        et.getEnumContents({ types })
      );
    });

  const enumTypes: ('Enum' | 'Option')[] = [];

  if (usesEnum) {
    enumTypes.push('Enum');
  }
  if (usesOption) {
    enumTypes.push('Option');
  }

  const decl = DTS_TEMPLATE_ENUM_IMPORTER.replace('{TYPES}', enumTypes.join(', '));
  const enumImport = enumTypes.length ? `\n${decl}\n` : '';

  /*
    Then we replace them all on the main template
  */
  return DTS_TEMPLATE.replace('{ENUM_IMPORT}', enumImport)
    .replace('{STRUCTS}', structs.join('\n'))
    .replace('{ENUMS}', enums.join('\n'))
    .replace('{FNS_FRAGMENTS}', fnsFragments.join('\n    '))
    .replace('{FNS_TYPEDEFS}', fnsTypedefs.join('\n    '))
    .replace('{ENCODERS}', encoders.join('\n  '))
    .replace('{DECODERS}', decoders.join('\n  '))
    .replace(/\{NAME\}/g, name)
    .replace(/[\n]{3,}/g, '\n\n');
}
