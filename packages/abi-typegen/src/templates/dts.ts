import type { Abi } from '../abi/Abi';
import type { EnumType } from '../abi/types/EnumType';
import type { StructType } from '../abi/types/StructType';

/*
  Templates
*/
export function renderDtsEncoderTemplate(params: { functionName: string; input: string }) {
  const { functionName, input } = params;
  return `encodeFunctionData(functionFragment: '${functionName}', values: [${input}]): Uint8Array`;
}

export function renderDtsDecoderTemplate(params: { functionName: string }) {
  const { functionName } = params;
  return `decodeFunctionData(functionFragment: '${functionName}', data: BytesLike): DecodedValue`;
}

export function renderStructEncoderTemplate(params: { structName: string; values: string }) {
  const { structName, values } = params;
  return `export type ${structName} = { ${values} }`;
}

export function renderEnumEncoderTemplate(params: { enumName: string; values: string }) {
  const { enumName, values } = params;
  return `export type ${enumName} = Enum<{ ${values} }>`;
}

export function renderEnumImporterTemplate(params: { enumImports: string }) {
  const { enumImports } = params;
  return `import type { ${enumImports} } from "./common";`;
}

/*
  Render method
*/
export function renderDtsTemplate(params: { abi: Abi }) {
  const { name, types, functions, usesEnum, usesOption } = params.abi;

  /*
    First we format all attributes
  */
  const fnsTypedefs = functions.map((f) => f.getDeclaration());

  const fnsFragments = functions.map((f) => `${f.attributes.name}: FunctionFragment;`);

  const encoders = functions.map((f) =>
    renderDtsEncoderTemplate({
      functionName: f.attributes.name,
      input: f.attributes.inputs,
    })
  );

  const decoders = functions.map((f) =>
    renderDtsDecoderTemplate({
      functionName: f.attributes.name,
    })
  );

  const structs = types
    .filter((t) => t.name === 'struct')
    .map((t) => {
      const st = t as StructType; // only structs here
      const structName = st.getStructName();
      const values = st.getStructContents({ types });
      return renderStructEncoderTemplate({ structName, values });
    });

  const enums = types
    .filter((t) => t.name === 'enum')
    .map((t) => {
      const et = t as EnumType; // only enums here
      const structName = et.getStructName();
      const values = et.getEnumContents({ types });
      return renderStructEncoderTemplate({
        structName,
        values,
      });
    });

  // Handles Enum and Option conditionally/individually
  const enumTypes: ('Enum' | 'Option')[] = [];

  if (usesEnum) {
    enumTypes.push('Enum');
  }
  if (usesOption) {
    enumTypes.push('Option');
  }

  let enumImport = renderEnumImporterTemplate({ enumImports: enumTypes.join(', ') });

  enumImport = enumTypes.length ? `\n${enumImport}\n` : '';

  // glue everything
  const output = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import type {
  Interface,
  FunctionFragment,
  DecodedValue,
  Contract,
  BytesLike,
  BigNumberish,
  InvokeFunction,
  BN,
} from 'fuels'

${enumImport}

${enums.join('\n')}

${structs.join('\n')}

interface ${name}Interface extends Interface {
  functions: {
    ${fnsFragments.join('/')}
  }

  ${encoders.join('\n')}

  ${decoders.join('\n')}
}

export class ${name} extends Contract {
  interface: ${name}Interface
  functions: {
    ${fnsTypedefs.join('\n')}
  }
}`;

  return output.replace(/[\n]{3,}/g, '\n\n');
}
