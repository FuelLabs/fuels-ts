import type { Abi } from '../Abi';
import type { EnumType } from '../types/EnumType';
import type { StructType } from '../types/StructType';

/*
  Templates
*/
export function renderDtsEncoderTemplate(params: { functionName: string; input: string }) {
  const { functionName, input } = params;
  return `encodeFunctionData(functionFragment: '${functionName}', values: [${input}]): Uint8Array`;
}

export function renderDtsDecoderTemplate(params: { functionName: string }) {
  const { functionName } = params;
  return `decodeFunctionData(functionFragment: '${functionName}', data: BytesLike): DecodedValue`;
}

export function renderStructEncoderTemplate(params: {
  structName: string;
  typeAnnotations: string;
  values: string;
}) {
  const { structName, typeAnnotations, values } = params;
  return `export type ${structName}${typeAnnotations} = { ${values} }`;
}

export function renderEnumEncoderTemplate(params: { enumName: string; values: string }) {
  const { enumName, values } = params;
  return `export type ${enumName} = Enum<{ ${values} }>`;
}

export function renderEnumImporterTemplate(params: { commonTypesInUse: string[] }) {
  const { commonTypesInUse } = params;
  return `import type { ${commonTypesInUse.join(', ')} } from "./common";`;
}

/*
  Render method
*/
export function renderDtsTemplate(params: { abi: Abi }) {
  const { name, types, functions, commonTypesInUse } = params.abi;

  /*
    First we format all attributes
  */
  const fnsTypedefs = functions.map((f) => f.getDeclaration());

  const fnsFragments = functions.map((f) => `${f.attributes.name}: FunctionFragment;`);

  const encoders = functions.map((f) =>
    renderDtsEncoderTemplate({
      functionName: f.attributes.name,
      input: f.attributes.inputs,
    })
  );

  const decoders = functions.map((f) =>
    renderDtsDecoderTemplate({
      functionName: f.attributes.name,
    })
  );

  const structs = types
    .filter((t) => t.name === 'struct')
    .map((t) => {
      const st = t as StructType; // only structs here
      const structName = st.getStructName();
      const values = st.getStructContents({ types });
      const typeAnnotations = st.getStructDeclaration({ types });
      return renderStructEncoderTemplate({ structName, typeAnnotations, values });
    });

  const enums = types
    .filter((t) => t.name === 'enum')
    .map((t) => {
      const et = t as EnumType; // only enums here
      const enumName = et.getEnumName();
      const values = et.getEnumContents({ types });
      return renderEnumEncoderTemplate({
        enumName,
        values,
      });
    });

  // Handles custom common types
  let commonImports = renderEnumImporterTemplate({ commonTypesInUse });

  commonImports = commonTypesInUse.length ? `\n${commonImports}\n` : '';

  // glue everything
  const output = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import type {
  Interface,
  FunctionFragment,
  DecodedValue,
  Contract,
  BytesLike,
  BigNumberish,
  InvokeFunction,
  BN,
} from 'fuels'

${commonImports}

${enums.join('\n')}

${structs.join('\n')}

interface ${name}Interface extends Interface {
  functions: {
    ${fnsFragments.join('\n    ')}
  }

  ${encoders.join('\n  ')}

  ${decoders.join('\n  ')}
}

export class ${name} extends Contract {
  interface: ${name}Interface
  functions: {
    ${fnsTypedefs.join('\n    ')}
  }
}`;

  return output.replace(/[\n]{3,}/g, '\n\n');
}
