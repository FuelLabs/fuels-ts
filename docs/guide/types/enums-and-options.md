---
title: "Enums And Options"
parent: "Types"
grand_parent: "Guide"
---

[info]: this file is autogenerated
# Enums

Here are some examples of `Enums` in Sway:

```rust
pub enum SmallEnum {
    Empty: (),
}

pub enum BigEnum {
    AddressA: b256,
    AddressB: b256,
    AddressC: b256,
}
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/test-projects/coverage-contract/src/main.sw#L37-L47)

---


And the same structures represented in TypeScript, note that an `Enum` is essentially an `Object` in TypeScript.

Here is `SmallEnum`

```typescript
    const INPUT = { Empty: [] };
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/src/coverage-contract.test.ts#L173-L175)

---


Here is `BigEnum`

```typescript
    const INPUT = { AddressB: B256 };
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/src/coverage-contract.test.ts#L181-L183)

---


## Options

Sway supports the concept of the `Option` container, which allows for a variable to be either set with an expected value or to be exclusively marked as "no-value" (with an `undefined` in the case of TypeScript).

The `Option` is a special wrapper type of `Enum`.

This example shows that an input param with type `OptionalStringInput` can either be a `string` value or `undefined`

```typescript
type OptionalStringInput = Option<string>;

let someInput: OptionalStringInput = "dogs";
let noneInput: OptionalStringInput = undefined;
```

To help us understand how the TS-SDK handles Optional params, take this Sway method that expects three optional params which it attempts to add together.

```rust
    fn echo_option_three_u8(inputA: Option<u8>, inputB: Option<u8>, inputC: Option<u8>) -> u8 {
        let value1 = match inputA {
            Option::Some(value) => value,
            Option::None => 0,
        };
        let value2 = match inputB {
            Option::Some(value) => value,
            Option::None => 0,
        };
        let value3 = match inputC {
            Option::Some(value) => value,
            Option::None => 0,
        };

        value1 + value2 + value3
    }
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/test-projects/coverage-contract/src/main.sw#L258-L275)

---


Using this Contract, our Optional params can either be the values expected, like so:

```typescript
    const INPUT_A = 1;
    const INPUT_B = 4;
    const INPUT_C = 5;

    // adds the three values (if Some value given) together
    const { value: Some } = await contractInstance.functions
      .echo_option_three_u8(INPUT_A, INPUT_B, INPUT_C)
      .call();

    // we receive the result of adding whatever was passed
    expect(Some).toStrictEqual(10);
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/src/coverage-contract.test.ts#L214-L226)

---


Or we can supply a partial list, where unsupplied values are converted to `Option<None>` (or `undefined`):

```typescript
    const INPUT = 1;

    // adds the three values together, but only first param value is supplied
    const { value: Some } = await contractInstance.functions.echo_option_three_u8(INPUT).call();

    // we receive the result of adding whatever was passed
    expect(Some).toStrictEqual(1);
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/src/coverage-contract.test.ts#L230-L238)

---

