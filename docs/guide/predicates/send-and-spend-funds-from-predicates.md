---
title: "Send And Spend Funds From Predicates"
parent: "Predicates"
grand_parent: "Guide"
---

[info]: this file is autogenerated
# Send and spend funds from predicates

Let's consider the following predicate example:


```rust
predicate;

use std::{b512::B512, ecr::ec_recover_address, inputs::input_predicate_data};

fn extract_pulic_key_and_match(signature: B512, expected_public_key: b256) -> u64 {
    let message_hash = 0x6aed34e6bddff5e1d872b5d7d5698a7b73abd6f3b33402732edc73ab9ffb9c70;
    if let Result::Ok(pub_key_sig) = ec_recover_address(signature, message_hash)
    {
        if pub_key_sig.value == expected_public_key {
            return 1;
        }
    }
    0
}

fn main() -> bool {
    let signatures: [B512; 3] = input_predicate_data(0);

    let public_keys = [
        0xe10f526b192593793b7a1559a391445faba82a1d669e3eb2dcd17f9c121b24b1,
        0x54944e5b8189827e470e5a8bacfc6c3667397dc4e1eef7ef3519d16d6d6c6610,
        0x577e424ee53a16e6a85291feabc8443862495f74ac39a706d2dd0b9fc16955eb,
    ];

    let mut matched_keys = 0;

    matched_keys = extract_pulic_key_and_match(signatures[0], public_keys[0]);
    matched_keys = matched_keys + extract_pulic_key_and_match(signatures[1], public_keys[1]);
    matched_keys = matched_keys + extract_pulic_key_and_match(signatures[2], public_keys[2]);

    matched_keys > 1
}
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/test-projects/predicate-triple-sig/src/main.sw#L1-L34)

---


This predicate accepts three signatures and matches them to three predefined public keys. The `ec_recover_address` function is used to recover the public key from the signatures. If two of three extracted public keys match the predefined public keys, the funds can be spent. Note that the signature order has to match the order of the predefined public keys.

Let's use the SDK to interact with the predicate. First, let's create three wallets with specific keys. Their hashed public keys are already hard-coded in the predicate.


```typescript
  import { Provider, Wallet } from 'fuels';
  import { seedTestWallet } from '@fuel-ts/wallet/test-utils';
  const provider = new Provider('http://127.0.0.1:4000/graphql');
  // Setup a private key
  const PRIVATE_KEY_1 = '0x862512a2363db2b3a375c0d4bbbd27172180d89f23f2e259bac850ab02619301';
  const PRIVATE_KEY_2 = '0x37fa81c84ccd547c30c176b118d5cb892bdb113e8e80141f266519422ef9eefd';
  const PRIVATE_KEY_3 = '0x976e5c3fa620092c718d852ca703b6da9e3075b9f2ecb8ed42d9f746bf26aafb';

  // Create the wallets, passing provider
  const wallet1: WalletUnlocked = Wallet.fromPrivateKey(PRIVATE_KEY_1, provider);
  const wallet2: WalletUnlocked = Wallet.fromPrivateKey(PRIVATE_KEY_2, provider);
  const wallet3: WalletUnlocked = Wallet.fromPrivateKey(PRIVATE_KEY_3, provider);
  const receiver = Wallet.generate({ provider });
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/src/doc-examples.test.ts#L349-L363)

---


Next, let's add some coins to the wallets.


```typescript
  import { Provider, Wallet } from 'fuels';
  import { seedTestWallet } from '@fuel-ts/wallet/test-utils';
  await seedTestWallet(wallet1, [{ assetId: NativeAssetId, amount: bn(1_000_000) }]);
  await seedTestWallet(wallet2, [{ assetId: NativeAssetId, amount: bn(2_000_000) }]);
  await seedTestWallet(wallet3, [{ assetId: NativeAssetId, amount: bn(300_000) }]);
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/src/doc-examples.test.ts#L365-L371)

---


Now we can load the predicate binary, and prepare some transaction variables.


```typescript
  import { Predicate, NativeAssetId } from 'fuels';
  const AbiInputs = {
    types: [
      {
        typeId: 0,
        type: 'bool',
      },
      {
        typeId: 1,
        type: 'b512',
      },
      {
        typeId: 2,
        type: '[_; 3]',
        components: [
          {
            name: '__array_element',
            type: 1,
          },
        ],
      },
    ],
    functions: [
      {
        inputs: [
          {
            name: 'data',
            type: 2,
          },
        ],
        name: 'main',
        output: {
          name: '',
          type: 0,
        },
      },
    ],
    loggedTypes: [],
  };
  const predicate = new Predicate(predicateTriple, AbiInputs);
  const amountToPredicate = 100_000;
  const amountToReceiver = 100;
  const initialPredicateBalance = await predicate.getBalance();
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/src/doc-examples.test.ts#L373-L417)

---


After the predicate address is generated we can send funds to it. Note that we are using the same `transfer` function as we used when sending funds to other wallets. We also make sure that the funds are indeed transferred.


```typescript
  const response = await wallet1.transfer(predicate.address, amountToPredicate);
  await response.waitForResult();
  const predicateBalance = await predicate.getBalance();

  // assert that predicate address now has the expected amount to predicate
  expect(bn(predicateBalance)).toEqual(initialPredicateBalance.add(amountToPredicate));
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/src/doc-examples.test.ts#L419-L426)

---


Alternatively, you can use `Wallet.submitPredicate` to setup a `Predicate` and use funds from the `Wallet` you submitted from.


```typescript
  const depositOnPredicate = await wallet1.transfer(predicate.address, 200);
  // Wait for Transaction to succeed
  await depositOnPredicate.waitForResult();
  const updatedPredicateBalance = await predicate.getBalance();

  // assert that predicate address now has the updated expected amount to predicate
  expect(bn(updatedPredicateBalance)).toEqual(
    initialPredicateBalance.add(amountToPredicate).add(200)
  );
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/src/doc-examples.test.ts#L428-L438)

---


To spend the funds that are now locked in this example's Predicate, we have to provide two out of three signatures whose public keys match the ones we defined in the predicate. In this example, the signatures are generated using a zeroed B256 value.


```typescript
  const dataToSign = '0x0000000000000000000000000000000000000000000000000000000000000000';
  const signature1 = await wallet1.signMessage(dataToSign);
  const signature2 = await wallet2.signMessage(dataToSign);
  const signature3 = await wallet3.signMessage(dataToSign);

  const signatures = [signature1, signature2, signature3];
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/src/doc-examples.test.ts#L440-L447)

---


After generating the signatures, we can send a transaction to spend the predicate funds. We use the `receiver` wallet as the recipient. We have to provide the predicate byte code and the required signatures. As we provide the correct data, we receive the funds and verify that the amount is correct.


```typescript
  const tx = await predicate.setData(signatures).transfer(receiver.address, amountToReceiver);
  await tx.waitForResult();

  // check balances
  const finalPredicateBalance = await predicate.getBalance();
  const receiverBalance = await receiver.getBalance();

  // assert that predicate address now has a zero balance
  expect(bn(initialPredicateBalance).lte(finalPredicateBalance)).toBeTruthy();
  // assert that predicate funds now belong to the receiver
  expect(bn(receiverBalance).gte(bn(amountToReceiver))).toBeTruthy();
```
###### [see code in context](https://github.com/FuelLabs/fuels-ts/blob/master/packages/fuel-gauge/src/doc-examples.test.ts#L449-L461)

---

